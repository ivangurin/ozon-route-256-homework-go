package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"route256.ozon.ru/project/loms/internal/model"
)

// ServiceMockMock implements orderservice.ServiceMock
type ServiceMockMock struct {
	t minimock.Tester

	funcCancel          func(ctx context.Context, orderID int64) (err error)
	inspectFuncCancel   func(ctx context.Context, orderID int64)
	afterCancelCounter  uint64
	beforeCancelCounter uint64
	CancelMock          mServiceMockMockCancel

	funcCreate          func(ctx context.Context, user int64, items model.OrderItems) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, user int64, items model.OrderItems)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mServiceMockMockCreate

	funcInfo          func(ctx context.Context, orderID int64) (op1 *model.Order, err error)
	inspectFuncInfo   func(ctx context.Context, orderID int64)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mServiceMockMockInfo

	funcPay          func(ctx context.Context, orderID int64) (err error)
	inspectFuncPay   func(ctx context.Context, orderID int64)
	afterPayCounter  uint64
	beforePayCounter uint64
	PayMock          mServiceMockMockPay
}

// NewServiceMockMock returns a mock for orderservice.ServiceMock
func NewServiceMockMock(t minimock.Tester) *ServiceMockMock {
	m := &ServiceMockMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelMock = mServiceMockMockCancel{mock: m}
	m.CancelMock.callArgs = []*ServiceMockMockCancelParams{}

	m.CreateMock = mServiceMockMockCreate{mock: m}
	m.CreateMock.callArgs = []*ServiceMockMockCreateParams{}

	m.InfoMock = mServiceMockMockInfo{mock: m}
	m.InfoMock.callArgs = []*ServiceMockMockInfoParams{}

	m.PayMock = mServiceMockMockPay{mock: m}
	m.PayMock.callArgs = []*ServiceMockMockPayParams{}

	return m
}

type mServiceMockMockCancel struct {
	mock               *ServiceMockMock
	defaultExpectation *ServiceMockMockCancelExpectation
	expectations       []*ServiceMockMockCancelExpectation

	callArgs []*ServiceMockMockCancelParams
	mutex    sync.RWMutex
}

// ServiceMockMockCancelExpectation specifies expectation struct of the ServiceMock.Cancel
type ServiceMockMockCancelExpectation struct {
	mock    *ServiceMockMock
	params  *ServiceMockMockCancelParams
	results *ServiceMockMockCancelResults
	Counter uint64
}

// ServiceMockMockCancelParams contains parameters of the ServiceMock.Cancel
type ServiceMockMockCancelParams struct {
	ctx     context.Context
	orderID int64
}

// ServiceMockMockCancelResults contains results of the ServiceMock.Cancel
type ServiceMockMockCancelResults struct {
	err error
}

// Expect sets up expected params for ServiceMock.Cancel
func (mmCancel *mServiceMockMockCancel) Expect(ctx context.Context, orderID int64) *mServiceMockMockCancel {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("ServiceMockMock.Cancel mock is already set by Set")
	}

	if mmCancel.defaultExpectation == nil {
		mmCancel.defaultExpectation = &ServiceMockMockCancelExpectation{}
	}

	mmCancel.defaultExpectation.params = &ServiceMockMockCancelParams{ctx, orderID}
	for _, e := range mmCancel.expectations {
		if minimock.Equal(e.params, mmCancel.defaultExpectation.params) {
			mmCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancel.defaultExpectation.params)
		}
	}

	return mmCancel
}

// Inspect accepts an inspector function that has same arguments as the ServiceMock.Cancel
func (mmCancel *mServiceMockMockCancel) Inspect(f func(ctx context.Context, orderID int64)) *mServiceMockMockCancel {
	if mmCancel.mock.inspectFuncCancel != nil {
		mmCancel.mock.t.Fatalf("Inspect function is already set for ServiceMockMock.Cancel")
	}

	mmCancel.mock.inspectFuncCancel = f

	return mmCancel
}

// Return sets up results that will be returned by ServiceMock.Cancel
func (mmCancel *mServiceMockMockCancel) Return(err error) *ServiceMockMock {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("ServiceMockMock.Cancel mock is already set by Set")
	}

	if mmCancel.defaultExpectation == nil {
		mmCancel.defaultExpectation = &ServiceMockMockCancelExpectation{mock: mmCancel.mock}
	}
	mmCancel.defaultExpectation.results = &ServiceMockMockCancelResults{err}
	return mmCancel.mock
}

// Set uses given function f to mock the ServiceMock.Cancel method
func (mmCancel *mServiceMockMockCancel) Set(f func(ctx context.Context, orderID int64) (err error)) *ServiceMockMock {
	if mmCancel.defaultExpectation != nil {
		mmCancel.mock.t.Fatalf("Default expectation is already set for the ServiceMock.Cancel method")
	}

	if len(mmCancel.expectations) > 0 {
		mmCancel.mock.t.Fatalf("Some expectations are already set for the ServiceMock.Cancel method")
	}

	mmCancel.mock.funcCancel = f
	return mmCancel.mock
}

// When sets expectation for the ServiceMock.Cancel which will trigger the result defined by the following
// Then helper
func (mmCancel *mServiceMockMockCancel) When(ctx context.Context, orderID int64) *ServiceMockMockCancelExpectation {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("ServiceMockMock.Cancel mock is already set by Set")
	}

	expectation := &ServiceMockMockCancelExpectation{
		mock:   mmCancel.mock,
		params: &ServiceMockMockCancelParams{ctx, orderID},
	}
	mmCancel.expectations = append(mmCancel.expectations, expectation)
	return expectation
}

// Then sets up ServiceMock.Cancel return parameters for the expectation previously defined by the When method
func (e *ServiceMockMockCancelExpectation) Then(err error) *ServiceMockMock {
	e.results = &ServiceMockMockCancelResults{err}
	return e.mock
}

// Cancel implements orderservice.ServiceMock
func (mmCancel *ServiceMockMock) Cancel(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmCancel.beforeCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmCancel.afterCancelCounter, 1)

	if mmCancel.inspectFuncCancel != nil {
		mmCancel.inspectFuncCancel(ctx, orderID)
	}

	mm_params := &ServiceMockMockCancelParams{ctx, orderID}

	// Record call args
	mmCancel.CancelMock.mutex.Lock()
	mmCancel.CancelMock.callArgs = append(mmCancel.CancelMock.callArgs, mm_params)
	mmCancel.CancelMock.mutex.Unlock()

	for _, e := range mmCancel.CancelMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancel.CancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancel.CancelMock.defaultExpectation.Counter, 1)
		mm_want := mmCancel.CancelMock.defaultExpectation.params
		mm_got := ServiceMockMockCancelParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancel.t.Errorf("ServiceMockMock.Cancel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancel.CancelMock.defaultExpectation.results
		if mm_results == nil {
			mmCancel.t.Fatal("No results are set for the ServiceMockMock.Cancel")
		}
		return (*mm_results).err
	}
	if mmCancel.funcCancel != nil {
		return mmCancel.funcCancel(ctx, orderID)
	}
	mmCancel.t.Fatalf("Unexpected call to ServiceMockMock.Cancel. %v %v", ctx, orderID)
	return
}

// CancelAfterCounter returns a count of finished ServiceMockMock.Cancel invocations
func (mmCancel *ServiceMockMock) CancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancel.afterCancelCounter)
}

// CancelBeforeCounter returns a count of ServiceMockMock.Cancel invocations
func (mmCancel *ServiceMockMock) CancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancel.beforeCancelCounter)
}

// Calls returns a list of arguments used in each call to ServiceMockMock.Cancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancel *mServiceMockMockCancel) Calls() []*ServiceMockMockCancelParams {
	mmCancel.mutex.RLock()

	argCopy := make([]*ServiceMockMockCancelParams, len(mmCancel.callArgs))
	copy(argCopy, mmCancel.callArgs)

	mmCancel.mutex.RUnlock()

	return argCopy
}

// MinimockCancelDone returns true if the count of the Cancel invocations corresponds
// the number of defined expectations
func (m *ServiceMockMock) MinimockCancelDone() bool {
	for _, e := range m.CancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancel != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelInspect logs each unmet expectation
func (m *ServiceMockMock) MinimockCancelInspect() {
	for _, e := range m.CancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMockMock.Cancel with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		if m.CancelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMockMock.Cancel")
		} else {
			m.t.Errorf("Expected call to ServiceMockMock.Cancel with params: %#v", *m.CancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancel != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		m.t.Error("Expected call to ServiceMockMock.Cancel")
	}
}

type mServiceMockMockCreate struct {
	mock               *ServiceMockMock
	defaultExpectation *ServiceMockMockCreateExpectation
	expectations       []*ServiceMockMockCreateExpectation

	callArgs []*ServiceMockMockCreateParams
	mutex    sync.RWMutex
}

// ServiceMockMockCreateExpectation specifies expectation struct of the ServiceMock.Create
type ServiceMockMockCreateExpectation struct {
	mock    *ServiceMockMock
	params  *ServiceMockMockCreateParams
	results *ServiceMockMockCreateResults
	Counter uint64
}

// ServiceMockMockCreateParams contains parameters of the ServiceMock.Create
type ServiceMockMockCreateParams struct {
	ctx   context.Context
	user  int64
	items model.OrderItems
}

// ServiceMockMockCreateResults contains results of the ServiceMock.Create
type ServiceMockMockCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for ServiceMock.Create
func (mmCreate *mServiceMockMockCreate) Expect(ctx context.Context, user int64, items model.OrderItems) *mServiceMockMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMockMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &ServiceMockMockCreateParams{ctx, user, items}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ServiceMock.Create
func (mmCreate *mServiceMockMockCreate) Inspect(f func(ctx context.Context, user int64, items model.OrderItems)) *mServiceMockMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ServiceMockMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ServiceMock.Create
func (mmCreate *mServiceMockMockCreate) Return(i1 int64, err error) *ServiceMockMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMockMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ServiceMockMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the ServiceMock.Create method
func (mmCreate *mServiceMockMockCreate) Set(f func(ctx context.Context, user int64, items model.OrderItems) (i1 int64, err error)) *ServiceMockMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ServiceMock.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ServiceMock.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the ServiceMock.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mServiceMockMockCreate) When(ctx context.Context, user int64, items model.OrderItems) *ServiceMockMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMockMock.Create mock is already set by Set")
	}

	expectation := &ServiceMockMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ServiceMockMockCreateParams{ctx, user, items},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ServiceMock.Create return parameters for the expectation previously defined by the When method
func (e *ServiceMockMockCreateExpectation) Then(i1 int64, err error) *ServiceMockMock {
	e.results = &ServiceMockMockCreateResults{i1, err}
	return e.mock
}

// Create implements orderservice.ServiceMock
func (mmCreate *ServiceMockMock) Create(ctx context.Context, user int64, items model.OrderItems) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, user, items)
	}

	mm_params := &ServiceMockMockCreateParams{ctx, user, items}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := ServiceMockMockCreateParams{ctx, user, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ServiceMockMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ServiceMockMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, user, items)
	}
	mmCreate.t.Fatalf("Unexpected call to ServiceMockMock.Create. %v %v %v", ctx, user, items)
	return
}

// CreateAfterCounter returns a count of finished ServiceMockMock.Create invocations
func (mmCreate *ServiceMockMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ServiceMockMock.Create invocations
func (mmCreate *ServiceMockMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ServiceMockMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mServiceMockMockCreate) Calls() []*ServiceMockMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ServiceMockMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ServiceMockMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *ServiceMockMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMockMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMockMock.Create")
		} else {
			m.t.Errorf("Expected call to ServiceMockMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to ServiceMockMock.Create")
	}
}

type mServiceMockMockInfo struct {
	mock               *ServiceMockMock
	defaultExpectation *ServiceMockMockInfoExpectation
	expectations       []*ServiceMockMockInfoExpectation

	callArgs []*ServiceMockMockInfoParams
	mutex    sync.RWMutex
}

// ServiceMockMockInfoExpectation specifies expectation struct of the ServiceMock.Info
type ServiceMockMockInfoExpectation struct {
	mock    *ServiceMockMock
	params  *ServiceMockMockInfoParams
	results *ServiceMockMockInfoResults
	Counter uint64
}

// ServiceMockMockInfoParams contains parameters of the ServiceMock.Info
type ServiceMockMockInfoParams struct {
	ctx     context.Context
	orderID int64
}

// ServiceMockMockInfoResults contains results of the ServiceMock.Info
type ServiceMockMockInfoResults struct {
	op1 *model.Order
	err error
}

// Expect sets up expected params for ServiceMock.Info
func (mmInfo *mServiceMockMockInfo) Expect(ctx context.Context, orderID int64) *mServiceMockMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("ServiceMockMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &ServiceMockMockInfoExpectation{}
	}

	mmInfo.defaultExpectation.params = &ServiceMockMockInfoParams{ctx, orderID}
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the ServiceMock.Info
func (mmInfo *mServiceMockMockInfo) Inspect(f func(ctx context.Context, orderID int64)) *mServiceMockMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for ServiceMockMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by ServiceMock.Info
func (mmInfo *mServiceMockMockInfo) Return(op1 *model.Order, err error) *ServiceMockMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("ServiceMockMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &ServiceMockMockInfoExpectation{mock: mmInfo.mock}
	}
	mmInfo.defaultExpectation.results = &ServiceMockMockInfoResults{op1, err}
	return mmInfo.mock
}

// Set uses given function f to mock the ServiceMock.Info method
func (mmInfo *mServiceMockMockInfo) Set(f func(ctx context.Context, orderID int64) (op1 *model.Order, err error)) *ServiceMockMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the ServiceMock.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the ServiceMock.Info method")
	}

	mmInfo.mock.funcInfo = f
	return mmInfo.mock
}

// When sets expectation for the ServiceMock.Info which will trigger the result defined by the following
// Then helper
func (mmInfo *mServiceMockMockInfo) When(ctx context.Context, orderID int64) *ServiceMockMockInfoExpectation {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("ServiceMockMock.Info mock is already set by Set")
	}

	expectation := &ServiceMockMockInfoExpectation{
		mock:   mmInfo.mock,
		params: &ServiceMockMockInfoParams{ctx, orderID},
	}
	mmInfo.expectations = append(mmInfo.expectations, expectation)
	return expectation
}

// Then sets up ServiceMock.Info return parameters for the expectation previously defined by the When method
func (e *ServiceMockMockInfoExpectation) Then(op1 *model.Order, err error) *ServiceMockMock {
	e.results = &ServiceMockMockInfoResults{op1, err}
	return e.mock
}

// Info implements orderservice.ServiceMock
func (mmInfo *ServiceMockMock) Info(ctx context.Context, orderID int64) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(ctx, orderID)
	}

	mm_params := &ServiceMockMockInfoParams{ctx, orderID}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_got := ServiceMockMockInfoParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("ServiceMockMock.Info got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInfo.InfoMock.defaultExpectation.results
		if mm_results == nil {
			mmInfo.t.Fatal("No results are set for the ServiceMockMock.Info")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmInfo.funcInfo != nil {
		return mmInfo.funcInfo(ctx, orderID)
	}
	mmInfo.t.Fatalf("Unexpected call to ServiceMockMock.Info. %v %v", ctx, orderID)
	return
}

// InfoAfterCounter returns a count of finished ServiceMockMock.Info invocations
func (mmInfo *ServiceMockMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of ServiceMockMock.Info invocations
func (mmInfo *ServiceMockMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to ServiceMockMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mServiceMockMockInfo) Calls() []*ServiceMockMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*ServiceMockMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *ServiceMockMock) MinimockInfoDone() bool {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfoInspect logs each unmet expectation
func (m *ServiceMockMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMockMock.Info with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMockMock.Info")
		} else {
			m.t.Errorf("Expected call to ServiceMockMock.Info with params: %#v", *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		m.t.Error("Expected call to ServiceMockMock.Info")
	}
}

type mServiceMockMockPay struct {
	mock               *ServiceMockMock
	defaultExpectation *ServiceMockMockPayExpectation
	expectations       []*ServiceMockMockPayExpectation

	callArgs []*ServiceMockMockPayParams
	mutex    sync.RWMutex
}

// ServiceMockMockPayExpectation specifies expectation struct of the ServiceMock.Pay
type ServiceMockMockPayExpectation struct {
	mock    *ServiceMockMock
	params  *ServiceMockMockPayParams
	results *ServiceMockMockPayResults
	Counter uint64
}

// ServiceMockMockPayParams contains parameters of the ServiceMock.Pay
type ServiceMockMockPayParams struct {
	ctx     context.Context
	orderID int64
}

// ServiceMockMockPayResults contains results of the ServiceMock.Pay
type ServiceMockMockPayResults struct {
	err error
}

// Expect sets up expected params for ServiceMock.Pay
func (mmPay *mServiceMockMockPay) Expect(ctx context.Context, orderID int64) *mServiceMockMockPay {
	if mmPay.mock.funcPay != nil {
		mmPay.mock.t.Fatalf("ServiceMockMock.Pay mock is already set by Set")
	}

	if mmPay.defaultExpectation == nil {
		mmPay.defaultExpectation = &ServiceMockMockPayExpectation{}
	}

	mmPay.defaultExpectation.params = &ServiceMockMockPayParams{ctx, orderID}
	for _, e := range mmPay.expectations {
		if minimock.Equal(e.params, mmPay.defaultExpectation.params) {
			mmPay.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPay.defaultExpectation.params)
		}
	}

	return mmPay
}

// Inspect accepts an inspector function that has same arguments as the ServiceMock.Pay
func (mmPay *mServiceMockMockPay) Inspect(f func(ctx context.Context, orderID int64)) *mServiceMockMockPay {
	if mmPay.mock.inspectFuncPay != nil {
		mmPay.mock.t.Fatalf("Inspect function is already set for ServiceMockMock.Pay")
	}

	mmPay.mock.inspectFuncPay = f

	return mmPay
}

// Return sets up results that will be returned by ServiceMock.Pay
func (mmPay *mServiceMockMockPay) Return(err error) *ServiceMockMock {
	if mmPay.mock.funcPay != nil {
		mmPay.mock.t.Fatalf("ServiceMockMock.Pay mock is already set by Set")
	}

	if mmPay.defaultExpectation == nil {
		mmPay.defaultExpectation = &ServiceMockMockPayExpectation{mock: mmPay.mock}
	}
	mmPay.defaultExpectation.results = &ServiceMockMockPayResults{err}
	return mmPay.mock
}

// Set uses given function f to mock the ServiceMock.Pay method
func (mmPay *mServiceMockMockPay) Set(f func(ctx context.Context, orderID int64) (err error)) *ServiceMockMock {
	if mmPay.defaultExpectation != nil {
		mmPay.mock.t.Fatalf("Default expectation is already set for the ServiceMock.Pay method")
	}

	if len(mmPay.expectations) > 0 {
		mmPay.mock.t.Fatalf("Some expectations are already set for the ServiceMock.Pay method")
	}

	mmPay.mock.funcPay = f
	return mmPay.mock
}

// When sets expectation for the ServiceMock.Pay which will trigger the result defined by the following
// Then helper
func (mmPay *mServiceMockMockPay) When(ctx context.Context, orderID int64) *ServiceMockMockPayExpectation {
	if mmPay.mock.funcPay != nil {
		mmPay.mock.t.Fatalf("ServiceMockMock.Pay mock is already set by Set")
	}

	expectation := &ServiceMockMockPayExpectation{
		mock:   mmPay.mock,
		params: &ServiceMockMockPayParams{ctx, orderID},
	}
	mmPay.expectations = append(mmPay.expectations, expectation)
	return expectation
}

// Then sets up ServiceMock.Pay return parameters for the expectation previously defined by the When method
func (e *ServiceMockMockPayExpectation) Then(err error) *ServiceMockMock {
	e.results = &ServiceMockMockPayResults{err}
	return e.mock
}

// Pay implements orderservice.ServiceMock
func (mmPay *ServiceMockMock) Pay(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmPay.beforePayCounter, 1)
	defer mm_atomic.AddUint64(&mmPay.afterPayCounter, 1)

	if mmPay.inspectFuncPay != nil {
		mmPay.inspectFuncPay(ctx, orderID)
	}

	mm_params := &ServiceMockMockPayParams{ctx, orderID}

	// Record call args
	mmPay.PayMock.mutex.Lock()
	mmPay.PayMock.callArgs = append(mmPay.PayMock.callArgs, mm_params)
	mmPay.PayMock.mutex.Unlock()

	for _, e := range mmPay.PayMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPay.PayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPay.PayMock.defaultExpectation.Counter, 1)
		mm_want := mmPay.PayMock.defaultExpectation.params
		mm_got := ServiceMockMockPayParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPay.t.Errorf("ServiceMockMock.Pay got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPay.PayMock.defaultExpectation.results
		if mm_results == nil {
			mmPay.t.Fatal("No results are set for the ServiceMockMock.Pay")
		}
		return (*mm_results).err
	}
	if mmPay.funcPay != nil {
		return mmPay.funcPay(ctx, orderID)
	}
	mmPay.t.Fatalf("Unexpected call to ServiceMockMock.Pay. %v %v", ctx, orderID)
	return
}

// PayAfterCounter returns a count of finished ServiceMockMock.Pay invocations
func (mmPay *ServiceMockMock) PayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPay.afterPayCounter)
}

// PayBeforeCounter returns a count of ServiceMockMock.Pay invocations
func (mmPay *ServiceMockMock) PayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPay.beforePayCounter)
}

// Calls returns a list of arguments used in each call to ServiceMockMock.Pay.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPay *mServiceMockMockPay) Calls() []*ServiceMockMockPayParams {
	mmPay.mutex.RLock()

	argCopy := make([]*ServiceMockMockPayParams, len(mmPay.callArgs))
	copy(argCopy, mmPay.callArgs)

	mmPay.mutex.RUnlock()

	return argCopy
}

// MinimockPayDone returns true if the count of the Pay invocations corresponds
// the number of defined expectations
func (m *ServiceMockMock) MinimockPayDone() bool {
	for _, e := range m.PayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPayCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPay != nil && mm_atomic.LoadUint64(&m.afterPayCounter) < 1 {
		return false
	}
	return true
}

// MinimockPayInspect logs each unmet expectation
func (m *ServiceMockMock) MinimockPayInspect() {
	for _, e := range m.PayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMockMock.Pay with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPayCounter) < 1 {
		if m.PayMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMockMock.Pay")
		} else {
			m.t.Errorf("Expected call to ServiceMockMock.Pay with params: %#v", *m.PayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPay != nil && mm_atomic.LoadUint64(&m.afterPayCounter) < 1 {
		m.t.Error("Expected call to ServiceMockMock.Pay")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMockMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCancelInspect()

		m.MinimockCreateInspect()

		m.MinimockInfoInspect()

		m.MinimockPayInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMockMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMockMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelDone() &&
		m.MinimockCreateDone() &&
		m.MinimockInfoDone() &&
		m.MinimockPayDone()
}

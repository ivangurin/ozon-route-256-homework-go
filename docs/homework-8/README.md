# Домашнее задание по модулю "Паттерны высоконагруженных приложений"

## Основное задание

- кэш
  - необходимо добавить in-memory кэш для запросов к ProductService ручки http://route256.pavl.uk:8080/docs/#/ProductService/ProductService_GetProduct
  - клиент с кэшированием должен соответствовать интерфейсу клиента без кэширования
  - клиент с кэшированием должен принимать обычный клиент в качестве зависимости
  - клиент с кэшированием должен принимать компонент сохранения и извлечения данных из кэша в качестве зависимости (для удобства назовем его Cacher)
  - реализовать базовую версию компонента сохранения и извлечения кэша (Cacher), одним из следующих способов:
    - 1. Кольцевой буфер
      - при инициализации задается максимальный размер кэша (максимальное количество элементов)
      - при создании аллоцируется map заданного размера и кольцевой буфер
      - map хранит в себе значения по ключу кэширования
      - кольцевой буфер содержит ключи map в порядке вставки. При добавлении нового элемента в кэш необходимо добавить ключ в кольцевой буфер и сохранить значение в кэш по этому ключу в map. Если в кольцевом буфере позиция записи уже занята (буфер полностью заполнен и мы идем по второму кругу), то ключ который хранился по данной позиции в кольцевом буфере должен удалиться из map.
      - количество элементов в map не превышает размера кольцевого буфера
      - в качестве map использовать шардированную map или sync.map
      - компонент должен принимать опции с помощью которых можно настроить максимальный размер кэша и количество шардов в map (для реализации шардированной map)
      - без передачи опций должны быть предустановлены значения по-умолчанию
      - компонент должен быть потокобезопасным и корректно работать при конкурентных запросах
    - 2. LRU двусвязный список
      - при инициализации задается максимальный размер кэша (максимальное количество элементов)
      - аналогичным образом (как и в случае с кольцевым буфером) создается map для доступа по ключу кэша
      - вместо кольцевого буфера необходимо использовать двусвязный список (https://pkg.go.dev/container/list или аналог)
      - в map в качестве значений хранятся элементы двусвязного списка
      - если в кэше (в map) нет нужного ключа, то осуществляется получения значения из мастер-системы (ProductService), кэш сохраняется и в map и в начало списка, при этом значение в хвосте списка удаляется из самого списка и из map.
      - если ключ уже присутствует в кэше, на любой позиции, то позиция данного ключа перемещается в начало списка, никакие элементы не удаляются
      - в каждый момент времени длина списка и размер map не превосходят заданного в конфигурации N
      - компонент должен принимать опции с помощью которых можно настроить максимальное количество элементов в кэше и, возможно, иные настройки
      - без передачи опций должны быть предустановлены значения по-умолчанию
      - компонент должен быть потокобезопасным и корректно работать при конкурентных запросах
  - если в кэше нет нужной информации, то по прежнему идем в ProductService и сохраняем данные в кэше
- шардирование
  - настроить еще один инстанс postgres в docker окружении
  - настроить выполнение миграций с помощью make и goose чтобы они отрабатывали на всех шардах
  - настроить подключения в приложении
  - создать компонент (назовем ShardManager)
    - компонент позволяет получить подключение к шарду по ключу шардирования
    - компонент принимает функцию шардирования и подключения к шардам
    - функция шардирования принимает значение ключа шардирования и возвращает номер шарда
  - доработать репозитории таким образом, чтобы новые заказы создавались на каждом из шардов
  - метод получения заказа по идентификатору должен обслуживаться запросом к одному шарду
  - перевести все ручки, которые создают/изменяют/читают заказы на работу с шардированной БД
  - для работы со stocks и другими сущностями можно всегда использовать конкретный шард (зафиксировать индекс шарда), либо вынести работу с ними в отдельный postgres. Шардировать другие сущности не нужно 

## Дополнительное задание

- кэш
    - вместо in-memory реализации кэша ProductService GetProduct использовать Redis
        - настроить docker контейнер с Redis
        - настроить конфигурацию приложения и инициировать подключение
        - реализовать интерфейс Cacher с использованием Redis
        - настройки времени жизни и прочего брать из настроек приложения
    - защитить клиент с кэшированием от обновления кэша для конкретного продукта пока другой поток выполняет запрос к ProductService с этим ProductID
    - защитить клиент с кэшированием от нескольких одновременных походов к ProductService с одним ProductID: пока выполняется запрос в сервис с конкретным ProductID остальные потоки, запрашивающие этот ProductID, должны дождаться ответа и, возможно, записи в кэш
    - добавить метрики, которые позволят вычислить hit ratio кэша и время ответа для cache hit и cache miss
- шардирование
  - реализовать метод получения списка заказов с разных шардов с последующим объединением результатов, заказы должны быть упорядочены по ID заказа по убыванию

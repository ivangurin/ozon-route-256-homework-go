package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_cartservice "route256.ozon.ru/project/cart/internal/service/cart_service"
)

// ServiceMockMock implements cartservice.ServiceMock
type ServiceMockMock struct {
	t minimock.Tester

	funcAddItem          func(ctx context.Context, userID int64, skuID int64, quantity uint16) (err error)
	inspectFuncAddItem   func(ctx context.Context, userID int64, skuID int64, quantity uint16)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mServiceMockMockAddItem

	funcDeleteItem          func(ctx context.Context, userID int64, skuID int64) (err error)
	inspectFuncDeleteItem   func(ctx context.Context, userID int64, skuID int64)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mServiceMockMockDeleteItem

	funcDeleteItemsByUserID          func(ctx context.Context, userID int64) (err error)
	inspectFuncDeleteItemsByUserID   func(ctx context.Context, userID int64)
	afterDeleteItemsByUserIDCounter  uint64
	beforeDeleteItemsByUserIDCounter uint64
	DeleteItemsByUserIDMock          mServiceMockMockDeleteItemsByUserID

	funcGetItemsByUserID          func(ctx context.Context, userID int64) (cp1 *mm_cartservice.Cart, err error)
	inspectFuncGetItemsByUserID   func(ctx context.Context, userID int64)
	afterGetItemsByUserIDCounter  uint64
	beforeGetItemsByUserIDCounter uint64
	GetItemsByUserIDMock          mServiceMockMockGetItemsByUserID
}

// NewServiceMockMock returns a mock for cartservice.ServiceMock
func NewServiceMockMock(t minimock.Tester) *ServiceMockMock {
	m := &ServiceMockMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mServiceMockMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*ServiceMockMockAddItemParams{}

	m.DeleteItemMock = mServiceMockMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*ServiceMockMockDeleteItemParams{}

	m.DeleteItemsByUserIDMock = mServiceMockMockDeleteItemsByUserID{mock: m}
	m.DeleteItemsByUserIDMock.callArgs = []*ServiceMockMockDeleteItemsByUserIDParams{}

	m.GetItemsByUserIDMock = mServiceMockMockGetItemsByUserID{mock: m}
	m.GetItemsByUserIDMock.callArgs = []*ServiceMockMockGetItemsByUserIDParams{}

	return m
}

type mServiceMockMockAddItem struct {
	mock               *ServiceMockMock
	defaultExpectation *ServiceMockMockAddItemExpectation
	expectations       []*ServiceMockMockAddItemExpectation

	callArgs []*ServiceMockMockAddItemParams
	mutex    sync.RWMutex
}

// ServiceMockMockAddItemExpectation specifies expectation struct of the ServiceMock.AddItem
type ServiceMockMockAddItemExpectation struct {
	mock    *ServiceMockMock
	params  *ServiceMockMockAddItemParams
	results *ServiceMockMockAddItemResults
	Counter uint64
}

// ServiceMockMockAddItemParams contains parameters of the ServiceMock.AddItem
type ServiceMockMockAddItemParams struct {
	ctx      context.Context
	userID   int64
	skuID    int64
	quantity uint16
}

// ServiceMockMockAddItemResults contains results of the ServiceMock.AddItem
type ServiceMockMockAddItemResults struct {
	err error
}

// Expect sets up expected params for ServiceMock.AddItem
func (mmAddItem *mServiceMockMockAddItem) Expect(ctx context.Context, userID int64, skuID int64, quantity uint16) *mServiceMockMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMockMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ServiceMockMockAddItemExpectation{}
	}

	mmAddItem.defaultExpectation.params = &ServiceMockMockAddItemParams{ctx, userID, skuID, quantity}
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the ServiceMock.AddItem
func (mmAddItem *mServiceMockMockAddItem) Inspect(f func(ctx context.Context, userID int64, skuID int64, quantity uint16)) *mServiceMockMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for ServiceMockMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by ServiceMock.AddItem
func (mmAddItem *mServiceMockMockAddItem) Return(err error) *ServiceMockMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMockMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ServiceMockMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &ServiceMockMockAddItemResults{err}
	return mmAddItem.mock
}

// Set uses given function f to mock the ServiceMock.AddItem method
func (mmAddItem *mServiceMockMockAddItem) Set(f func(ctx context.Context, userID int64, skuID int64, quantity uint16) (err error)) *ServiceMockMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the ServiceMock.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the ServiceMock.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	return mmAddItem.mock
}

// When sets expectation for the ServiceMock.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mServiceMockMockAddItem) When(ctx context.Context, userID int64, skuID int64, quantity uint16) *ServiceMockMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMockMock.AddItem mock is already set by Set")
	}

	expectation := &ServiceMockMockAddItemExpectation{
		mock:   mmAddItem.mock,
		params: &ServiceMockMockAddItemParams{ctx, userID, skuID, quantity},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up ServiceMock.AddItem return parameters for the expectation previously defined by the When method
func (e *ServiceMockMockAddItemExpectation) Then(err error) *ServiceMockMock {
	e.results = &ServiceMockMockAddItemResults{err}
	return e.mock
}

// AddItem implements cartservice.ServiceMock
func (mmAddItem *ServiceMockMock) AddItem(ctx context.Context, userID int64, skuID int64, quantity uint16) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, userID, skuID, quantity)
	}

	mm_params := &ServiceMockMockAddItemParams{ctx, userID, skuID, quantity}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_got := ServiceMockMockAddItemParams{ctx, userID, skuID, quantity}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("ServiceMockMock.AddItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the ServiceMockMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, userID, skuID, quantity)
	}
	mmAddItem.t.Fatalf("Unexpected call to ServiceMockMock.AddItem. %v %v %v %v", ctx, userID, skuID, quantity)
	return
}

// AddItemAfterCounter returns a count of finished ServiceMockMock.AddItem invocations
func (mmAddItem *ServiceMockMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of ServiceMockMock.AddItem invocations
func (mmAddItem *ServiceMockMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to ServiceMockMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mServiceMockMockAddItem) Calls() []*ServiceMockMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*ServiceMockMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *ServiceMockMock) MinimockAddItemDone() bool {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddItemInspect logs each unmet expectation
func (m *ServiceMockMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMockMock.AddItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMockMock.AddItem")
		} else {
			m.t.Errorf("Expected call to ServiceMockMock.AddItem with params: %#v", *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		m.t.Error("Expected call to ServiceMockMock.AddItem")
	}
}

type mServiceMockMockDeleteItem struct {
	mock               *ServiceMockMock
	defaultExpectation *ServiceMockMockDeleteItemExpectation
	expectations       []*ServiceMockMockDeleteItemExpectation

	callArgs []*ServiceMockMockDeleteItemParams
	mutex    sync.RWMutex
}

// ServiceMockMockDeleteItemExpectation specifies expectation struct of the ServiceMock.DeleteItem
type ServiceMockMockDeleteItemExpectation struct {
	mock    *ServiceMockMock
	params  *ServiceMockMockDeleteItemParams
	results *ServiceMockMockDeleteItemResults
	Counter uint64
}

// ServiceMockMockDeleteItemParams contains parameters of the ServiceMock.DeleteItem
type ServiceMockMockDeleteItemParams struct {
	ctx    context.Context
	userID int64
	skuID  int64
}

// ServiceMockMockDeleteItemResults contains results of the ServiceMock.DeleteItem
type ServiceMockMockDeleteItemResults struct {
	err error
}

// Expect sets up expected params for ServiceMock.DeleteItem
func (mmDeleteItem *mServiceMockMockDeleteItem) Expect(ctx context.Context, userID int64, skuID int64) *mServiceMockMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMockMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ServiceMockMockDeleteItemExpectation{}
	}

	mmDeleteItem.defaultExpectation.params = &ServiceMockMockDeleteItemParams{ctx, userID, skuID}
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the ServiceMock.DeleteItem
func (mmDeleteItem *mServiceMockMockDeleteItem) Inspect(f func(ctx context.Context, userID int64, skuID int64)) *mServiceMockMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for ServiceMockMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by ServiceMock.DeleteItem
func (mmDeleteItem *mServiceMockMockDeleteItem) Return(err error) *ServiceMockMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMockMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ServiceMockMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &ServiceMockMockDeleteItemResults{err}
	return mmDeleteItem.mock
}

// Set uses given function f to mock the ServiceMock.DeleteItem method
func (mmDeleteItem *mServiceMockMockDeleteItem) Set(f func(ctx context.Context, userID int64, skuID int64) (err error)) *ServiceMockMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the ServiceMock.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the ServiceMock.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	return mmDeleteItem.mock
}

// When sets expectation for the ServiceMock.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mServiceMockMockDeleteItem) When(ctx context.Context, userID int64, skuID int64) *ServiceMockMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMockMock.DeleteItem mock is already set by Set")
	}

	expectation := &ServiceMockMockDeleteItemExpectation{
		mock:   mmDeleteItem.mock,
		params: &ServiceMockMockDeleteItemParams{ctx, userID, skuID},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up ServiceMock.DeleteItem return parameters for the expectation previously defined by the When method
func (e *ServiceMockMockDeleteItemExpectation) Then(err error) *ServiceMockMock {
	e.results = &ServiceMockMockDeleteItemResults{err}
	return e.mock
}

// DeleteItem implements cartservice.ServiceMock
func (mmDeleteItem *ServiceMockMock) DeleteItem(ctx context.Context, userID int64, skuID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userID, skuID)
	}

	mm_params := &ServiceMockMockDeleteItemParams{ctx, userID, skuID}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_got := ServiceMockMockDeleteItemParams{ctx, userID, skuID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("ServiceMockMock.DeleteItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the ServiceMockMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userID, skuID)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to ServiceMockMock.DeleteItem. %v %v %v", ctx, userID, skuID)
	return
}

// DeleteItemAfterCounter returns a count of finished ServiceMockMock.DeleteItem invocations
func (mmDeleteItem *ServiceMockMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of ServiceMockMock.DeleteItem invocations
func (mmDeleteItem *ServiceMockMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to ServiceMockMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mServiceMockMockDeleteItem) Calls() []*ServiceMockMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*ServiceMockMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *ServiceMockMock) MinimockDeleteItemDone() bool {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *ServiceMockMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMockMock.DeleteItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMockMock.DeleteItem")
		} else {
			m.t.Errorf("Expected call to ServiceMockMock.DeleteItem with params: %#v", *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		m.t.Error("Expected call to ServiceMockMock.DeleteItem")
	}
}

type mServiceMockMockDeleteItemsByUserID struct {
	mock               *ServiceMockMock
	defaultExpectation *ServiceMockMockDeleteItemsByUserIDExpectation
	expectations       []*ServiceMockMockDeleteItemsByUserIDExpectation

	callArgs []*ServiceMockMockDeleteItemsByUserIDParams
	mutex    sync.RWMutex
}

// ServiceMockMockDeleteItemsByUserIDExpectation specifies expectation struct of the ServiceMock.DeleteItemsByUserID
type ServiceMockMockDeleteItemsByUserIDExpectation struct {
	mock    *ServiceMockMock
	params  *ServiceMockMockDeleteItemsByUserIDParams
	results *ServiceMockMockDeleteItemsByUserIDResults
	Counter uint64
}

// ServiceMockMockDeleteItemsByUserIDParams contains parameters of the ServiceMock.DeleteItemsByUserID
type ServiceMockMockDeleteItemsByUserIDParams struct {
	ctx    context.Context
	userID int64
}

// ServiceMockMockDeleteItemsByUserIDResults contains results of the ServiceMock.DeleteItemsByUserID
type ServiceMockMockDeleteItemsByUserIDResults struct {
	err error
}

// Expect sets up expected params for ServiceMock.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mServiceMockMockDeleteItemsByUserID) Expect(ctx context.Context, userID int64) *mServiceMockMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMockMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &ServiceMockMockDeleteItemsByUserIDExpectation{}
	}

	mmDeleteItemsByUserID.defaultExpectation.params = &ServiceMockMockDeleteItemsByUserIDParams{ctx, userID}
	for _, e := range mmDeleteItemsByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteItemsByUserID.defaultExpectation.params) {
			mmDeleteItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemsByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the ServiceMock.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mServiceMockMockDeleteItemsByUserID) Inspect(f func(ctx context.Context, userID int64)) *mServiceMockMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Inspect function is already set for ServiceMockMock.DeleteItemsByUserID")
	}

	mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID = f

	return mmDeleteItemsByUserID
}

// Return sets up results that will be returned by ServiceMock.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mServiceMockMockDeleteItemsByUserID) Return(err error) *ServiceMockMock {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMockMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &ServiceMockMockDeleteItemsByUserIDExpectation{mock: mmDeleteItemsByUserID.mock}
	}
	mmDeleteItemsByUserID.defaultExpectation.results = &ServiceMockMockDeleteItemsByUserIDResults{err}
	return mmDeleteItemsByUserID.mock
}

// Set uses given function f to mock the ServiceMock.DeleteItemsByUserID method
func (mmDeleteItemsByUserID *mServiceMockMockDeleteItemsByUserID) Set(f func(ctx context.Context, userID int64) (err error)) *ServiceMockMock {
	if mmDeleteItemsByUserID.defaultExpectation != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Default expectation is already set for the ServiceMock.DeleteItemsByUserID method")
	}

	if len(mmDeleteItemsByUserID.expectations) > 0 {
		mmDeleteItemsByUserID.mock.t.Fatalf("Some expectations are already set for the ServiceMock.DeleteItemsByUserID method")
	}

	mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID = f
	return mmDeleteItemsByUserID.mock
}

// When sets expectation for the ServiceMock.DeleteItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmDeleteItemsByUserID *mServiceMockMockDeleteItemsByUserID) When(ctx context.Context, userID int64) *ServiceMockMockDeleteItemsByUserIDExpectation {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMockMock.DeleteItemsByUserID mock is already set by Set")
	}

	expectation := &ServiceMockMockDeleteItemsByUserIDExpectation{
		mock:   mmDeleteItemsByUserID.mock,
		params: &ServiceMockMockDeleteItemsByUserIDParams{ctx, userID},
	}
	mmDeleteItemsByUserID.expectations = append(mmDeleteItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up ServiceMock.DeleteItemsByUserID return parameters for the expectation previously defined by the When method
func (e *ServiceMockMockDeleteItemsByUserIDExpectation) Then(err error) *ServiceMockMock {
	e.results = &ServiceMockMockDeleteItemsByUserIDResults{err}
	return e.mock
}

// DeleteItemsByUserID implements cartservice.ServiceMock
func (mmDeleteItemsByUserID *ServiceMockMock) DeleteItemsByUserID(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter, 1)

	if mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID(ctx, userID)
	}

	mm_params := &ServiceMockMockDeleteItemsByUserIDParams{ctx, userID}

	// Record call args
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Lock()
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs = append(mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs, mm_params)
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteItemsByUserID.DeleteItemsByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.params
		mm_got := ServiceMockMockDeleteItemsByUserIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemsByUserID.t.Errorf("ServiceMockMock.DeleteItemsByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemsByUserID.t.Fatal("No results are set for the ServiceMockMock.DeleteItemsByUserID")
		}
		return (*mm_results).err
	}
	if mmDeleteItemsByUserID.funcDeleteItemsByUserID != nil {
		return mmDeleteItemsByUserID.funcDeleteItemsByUserID(ctx, userID)
	}
	mmDeleteItemsByUserID.t.Fatalf("Unexpected call to ServiceMockMock.DeleteItemsByUserID. %v %v", ctx, userID)
	return
}

// DeleteItemsByUserIDAfterCounter returns a count of finished ServiceMockMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *ServiceMockMock) DeleteItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter)
}

// DeleteItemsByUserIDBeforeCounter returns a count of ServiceMockMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *ServiceMockMock) DeleteItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMockMock.DeleteItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemsByUserID *mServiceMockMockDeleteItemsByUserID) Calls() []*ServiceMockMockDeleteItemsByUserIDParams {
	mmDeleteItemsByUserID.mutex.RLock()

	argCopy := make([]*ServiceMockMockDeleteItemsByUserIDParams, len(mmDeleteItemsByUserID.callArgs))
	copy(argCopy, mmDeleteItemsByUserID.callArgs)

	mmDeleteItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsByUserIDDone returns true if the count of the DeleteItemsByUserID invocations corresponds
// the number of defined expectations
func (m *ServiceMockMock) MinimockDeleteItemsByUserIDDone() bool {
	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUserID != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteItemsByUserIDInspect logs each unmet expectation
func (m *ServiceMockMock) MinimockDeleteItemsByUserIDInspect() {
	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMockMock.DeleteItemsByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter) < 1 {
		if m.DeleteItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMockMock.DeleteItemsByUserID")
		} else {
			m.t.Errorf("Expected call to ServiceMockMock.DeleteItemsByUserID with params: %#v", *m.DeleteItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUserID != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter) < 1 {
		m.t.Error("Expected call to ServiceMockMock.DeleteItemsByUserID")
	}
}

type mServiceMockMockGetItemsByUserID struct {
	mock               *ServiceMockMock
	defaultExpectation *ServiceMockMockGetItemsByUserIDExpectation
	expectations       []*ServiceMockMockGetItemsByUserIDExpectation

	callArgs []*ServiceMockMockGetItemsByUserIDParams
	mutex    sync.RWMutex
}

// ServiceMockMockGetItemsByUserIDExpectation specifies expectation struct of the ServiceMock.GetItemsByUserID
type ServiceMockMockGetItemsByUserIDExpectation struct {
	mock    *ServiceMockMock
	params  *ServiceMockMockGetItemsByUserIDParams
	results *ServiceMockMockGetItemsByUserIDResults
	Counter uint64
}

// ServiceMockMockGetItemsByUserIDParams contains parameters of the ServiceMock.GetItemsByUserID
type ServiceMockMockGetItemsByUserIDParams struct {
	ctx    context.Context
	userID int64
}

// ServiceMockMockGetItemsByUserIDResults contains results of the ServiceMock.GetItemsByUserID
type ServiceMockMockGetItemsByUserIDResults struct {
	cp1 *mm_cartservice.Cart
	err error
}

// Expect sets up expected params for ServiceMock.GetItemsByUserID
func (mmGetItemsByUserID *mServiceMockMockGetItemsByUserID) Expect(ctx context.Context, userID int64) *mServiceMockMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ServiceMockMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &ServiceMockMockGetItemsByUserIDExpectation{}
	}

	mmGetItemsByUserID.defaultExpectation.params = &ServiceMockMockGetItemsByUserIDParams{ctx, userID}
	for _, e := range mmGetItemsByUserID.expectations {
		if minimock.Equal(e.params, mmGetItemsByUserID.defaultExpectation.params) {
			mmGetItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByUserID.defaultExpectation.params)
		}
	}

	return mmGetItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the ServiceMock.GetItemsByUserID
func (mmGetItemsByUserID *mServiceMockMockGetItemsByUserID) Inspect(f func(ctx context.Context, userID int64)) *mServiceMockMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Inspect function is already set for ServiceMockMock.GetItemsByUserID")
	}

	mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID = f

	return mmGetItemsByUserID
}

// Return sets up results that will be returned by ServiceMock.GetItemsByUserID
func (mmGetItemsByUserID *mServiceMockMockGetItemsByUserID) Return(cp1 *mm_cartservice.Cart, err error) *ServiceMockMock {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ServiceMockMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &ServiceMockMockGetItemsByUserIDExpectation{mock: mmGetItemsByUserID.mock}
	}
	mmGetItemsByUserID.defaultExpectation.results = &ServiceMockMockGetItemsByUserIDResults{cp1, err}
	return mmGetItemsByUserID.mock
}

// Set uses given function f to mock the ServiceMock.GetItemsByUserID method
func (mmGetItemsByUserID *mServiceMockMockGetItemsByUserID) Set(f func(ctx context.Context, userID int64) (cp1 *mm_cartservice.Cart, err error)) *ServiceMockMock {
	if mmGetItemsByUserID.defaultExpectation != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Default expectation is already set for the ServiceMock.GetItemsByUserID method")
	}

	if len(mmGetItemsByUserID.expectations) > 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Some expectations are already set for the ServiceMock.GetItemsByUserID method")
	}

	mmGetItemsByUserID.mock.funcGetItemsByUserID = f
	return mmGetItemsByUserID.mock
}

// When sets expectation for the ServiceMock.GetItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmGetItemsByUserID *mServiceMockMockGetItemsByUserID) When(ctx context.Context, userID int64) *ServiceMockMockGetItemsByUserIDExpectation {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ServiceMockMock.GetItemsByUserID mock is already set by Set")
	}

	expectation := &ServiceMockMockGetItemsByUserIDExpectation{
		mock:   mmGetItemsByUserID.mock,
		params: &ServiceMockMockGetItemsByUserIDParams{ctx, userID},
	}
	mmGetItemsByUserID.expectations = append(mmGetItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up ServiceMock.GetItemsByUserID return parameters for the expectation previously defined by the When method
func (e *ServiceMockMockGetItemsByUserIDExpectation) Then(cp1 *mm_cartservice.Cart, err error) *ServiceMockMock {
	e.results = &ServiceMockMockGetItemsByUserIDResults{cp1, err}
	return e.mock
}

// GetItemsByUserID implements cartservice.ServiceMock
func (mmGetItemsByUserID *ServiceMockMock) GetItemsByUserID(ctx context.Context, userID int64) (cp1 *mm_cartservice.Cart, err error) {
	mm_atomic.AddUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter, 1)

	if mmGetItemsByUserID.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.inspectFuncGetItemsByUserID(ctx, userID)
	}

	mm_params := &ServiceMockMockGetItemsByUserIDParams{ctx, userID}

	// Record call args
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Lock()
	mmGetItemsByUserID.GetItemsByUserIDMock.callArgs = append(mmGetItemsByUserID.GetItemsByUserIDMock.callArgs, mm_params)
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmGetItemsByUserID.GetItemsByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.params
		mm_got := ServiceMockMockGetItemsByUserIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByUserID.t.Errorf("ServiceMockMock.GetItemsByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByUserID.t.Fatal("No results are set for the ServiceMockMock.GetItemsByUserID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetItemsByUserID.funcGetItemsByUserID != nil {
		return mmGetItemsByUserID.funcGetItemsByUserID(ctx, userID)
	}
	mmGetItemsByUserID.t.Fatalf("Unexpected call to ServiceMockMock.GetItemsByUserID. %v %v", ctx, userID)
	return
}

// GetItemsByUserIDAfterCounter returns a count of finished ServiceMockMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *ServiceMockMock) GetItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter)
}

// GetItemsByUserIDBeforeCounter returns a count of ServiceMockMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *ServiceMockMock) GetItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMockMock.GetItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByUserID *mServiceMockMockGetItemsByUserID) Calls() []*ServiceMockMockGetItemsByUserIDParams {
	mmGetItemsByUserID.mutex.RLock()

	argCopy := make([]*ServiceMockMockGetItemsByUserIDParams, len(mmGetItemsByUserID.callArgs))
	copy(argCopy, mmGetItemsByUserID.callArgs)

	mmGetItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByUserIDDone returns true if the count of the GetItemsByUserID invocations corresponds
// the number of defined expectations
func (m *ServiceMockMock) MinimockGetItemsByUserIDDone() bool {
	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserID != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetItemsByUserIDInspect logs each unmet expectation
func (m *ServiceMockMock) MinimockGetItemsByUserIDInspect() {
	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMockMock.GetItemsByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter) < 1 {
		if m.GetItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMockMock.GetItemsByUserID")
		} else {
			m.t.Errorf("Expected call to ServiceMockMock.GetItemsByUserID with params: %#v", *m.GetItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserID != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter) < 1 {
		m.t.Error("Expected call to ServiceMockMock.GetItemsByUserID")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMockMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddItemInspect()

		m.MinimockDeleteItemInspect()

		m.MinimockDeleteItemsByUserIDInspect()

		m.MinimockGetItemsByUserIDInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMockMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMockMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockDeleteItemsByUserIDDone() &&
		m.MinimockGetItemsByUserIDDone()
}

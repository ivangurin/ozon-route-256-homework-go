package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_cartstorage "route256.ozon.ru/project/cart/internal/repository/cart_storage"
)

// StorageMockMock implements cartstorage.StorageMock
type StorageMockMock struct {
	t minimock.Tester

	funcAddItem          func(ctx context.Context, userID int64, skuID int64, quantity uint16) (err error)
	inspectFuncAddItem   func(ctx context.Context, userID int64, skuID int64, quantity uint16)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mStorageMockMockAddItem

	funcDeleteItem          func(ctx context.Context, userID int64, skuID int64) (err error)
	inspectFuncDeleteItem   func(ctx context.Context, userID int64, skuID int64)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mStorageMockMockDeleteItem

	funcDeleteItemsByUserID          func(ctx context.Context, userID int64) (err error)
	inspectFuncDeleteItemsByUserID   func(ctx context.Context, userID int64)
	afterDeleteItemsByUserIDCounter  uint64
	beforeDeleteItemsByUserIDCounter uint64
	DeleteItemsByUserIDMock          mStorageMockMockDeleteItemsByUserID

	funcGetItemsByUserID          func(ctx context.Context, userID int64) (cp1 *mm_cartstorage.Cart, err error)
	inspectFuncGetItemsByUserID   func(ctx context.Context, userID int64)
	afterGetItemsByUserIDCounter  uint64
	beforeGetItemsByUserIDCounter uint64
	GetItemsByUserIDMock          mStorageMockMockGetItemsByUserID

	funcReset          func()
	inspectFuncReset   func()
	afterResetCounter  uint64
	beforeResetCounter uint64
	ResetMock          mStorageMockMockReset
}

// NewStorageMockMock returns a mock for cartstorage.StorageMock
func NewStorageMockMock(t minimock.Tester) *StorageMockMock {
	m := &StorageMockMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mStorageMockMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*StorageMockMockAddItemParams{}

	m.DeleteItemMock = mStorageMockMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*StorageMockMockDeleteItemParams{}

	m.DeleteItemsByUserIDMock = mStorageMockMockDeleteItemsByUserID{mock: m}
	m.DeleteItemsByUserIDMock.callArgs = []*StorageMockMockDeleteItemsByUserIDParams{}

	m.GetItemsByUserIDMock = mStorageMockMockGetItemsByUserID{mock: m}
	m.GetItemsByUserIDMock.callArgs = []*StorageMockMockGetItemsByUserIDParams{}

	m.ResetMock = mStorageMockMockReset{mock: m}

	return m
}

type mStorageMockMockAddItem struct {
	mock               *StorageMockMock
	defaultExpectation *StorageMockMockAddItemExpectation
	expectations       []*StorageMockMockAddItemExpectation

	callArgs []*StorageMockMockAddItemParams
	mutex    sync.RWMutex
}

// StorageMockMockAddItemExpectation specifies expectation struct of the StorageMock.AddItem
type StorageMockMockAddItemExpectation struct {
	mock    *StorageMockMock
	params  *StorageMockMockAddItemParams
	results *StorageMockMockAddItemResults
	Counter uint64
}

// StorageMockMockAddItemParams contains parameters of the StorageMock.AddItem
type StorageMockMockAddItemParams struct {
	ctx      context.Context
	userID   int64
	skuID    int64
	quantity uint16
}

// StorageMockMockAddItemResults contains results of the StorageMock.AddItem
type StorageMockMockAddItemResults struct {
	err error
}

// Expect sets up expected params for StorageMock.AddItem
func (mmAddItem *mStorageMockMockAddItem) Expect(ctx context.Context, userID int64, skuID int64, quantity uint16) *mStorageMockMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMockMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockMockAddItemExpectation{}
	}

	mmAddItem.defaultExpectation.params = &StorageMockMockAddItemParams{ctx, userID, skuID, quantity}
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the StorageMock.AddItem
func (mmAddItem *mStorageMockMockAddItem) Inspect(f func(ctx context.Context, userID int64, skuID int64, quantity uint16)) *mStorageMockMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for StorageMockMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by StorageMock.AddItem
func (mmAddItem *mStorageMockMockAddItem) Return(err error) *StorageMockMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMockMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &StorageMockMockAddItemResults{err}
	return mmAddItem.mock
}

// Set uses given function f to mock the StorageMock.AddItem method
func (mmAddItem *mStorageMockMockAddItem) Set(f func(ctx context.Context, userID int64, skuID int64, quantity uint16) (err error)) *StorageMockMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the StorageMock.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the StorageMock.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	return mmAddItem.mock
}

// When sets expectation for the StorageMock.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mStorageMockMockAddItem) When(ctx context.Context, userID int64, skuID int64, quantity uint16) *StorageMockMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMockMock.AddItem mock is already set by Set")
	}

	expectation := &StorageMockMockAddItemExpectation{
		mock:   mmAddItem.mock,
		params: &StorageMockMockAddItemParams{ctx, userID, skuID, quantity},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up StorageMock.AddItem return parameters for the expectation previously defined by the When method
func (e *StorageMockMockAddItemExpectation) Then(err error) *StorageMockMock {
	e.results = &StorageMockMockAddItemResults{err}
	return e.mock
}

// AddItem implements cartstorage.StorageMock
func (mmAddItem *StorageMockMock) AddItem(ctx context.Context, userID int64, skuID int64, quantity uint16) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, userID, skuID, quantity)
	}

	mm_params := &StorageMockMockAddItemParams{ctx, userID, skuID, quantity}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_got := StorageMockMockAddItemParams{ctx, userID, skuID, quantity}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("StorageMockMock.AddItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the StorageMockMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, userID, skuID, quantity)
	}
	mmAddItem.t.Fatalf("Unexpected call to StorageMockMock.AddItem. %v %v %v %v", ctx, userID, skuID, quantity)
	return
}

// AddItemAfterCounter returns a count of finished StorageMockMock.AddItem invocations
func (mmAddItem *StorageMockMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of StorageMockMock.AddItem invocations
func (mmAddItem *StorageMockMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to StorageMockMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mStorageMockMockAddItem) Calls() []*StorageMockMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*StorageMockMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *StorageMockMock) MinimockAddItemDone() bool {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddItemInspect logs each unmet expectation
func (m *StorageMockMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMockMock.AddItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMockMock.AddItem")
		} else {
			m.t.Errorf("Expected call to StorageMockMock.AddItem with params: %#v", *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		m.t.Error("Expected call to StorageMockMock.AddItem")
	}
}

type mStorageMockMockDeleteItem struct {
	mock               *StorageMockMock
	defaultExpectation *StorageMockMockDeleteItemExpectation
	expectations       []*StorageMockMockDeleteItemExpectation

	callArgs []*StorageMockMockDeleteItemParams
	mutex    sync.RWMutex
}

// StorageMockMockDeleteItemExpectation specifies expectation struct of the StorageMock.DeleteItem
type StorageMockMockDeleteItemExpectation struct {
	mock    *StorageMockMock
	params  *StorageMockMockDeleteItemParams
	results *StorageMockMockDeleteItemResults
	Counter uint64
}

// StorageMockMockDeleteItemParams contains parameters of the StorageMock.DeleteItem
type StorageMockMockDeleteItemParams struct {
	ctx    context.Context
	userID int64
	skuID  int64
}

// StorageMockMockDeleteItemResults contains results of the StorageMock.DeleteItem
type StorageMockMockDeleteItemResults struct {
	err error
}

// Expect sets up expected params for StorageMock.DeleteItem
func (mmDeleteItem *mStorageMockMockDeleteItem) Expect(ctx context.Context, userID int64, skuID int64) *mStorageMockMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMockMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &StorageMockMockDeleteItemExpectation{}
	}

	mmDeleteItem.defaultExpectation.params = &StorageMockMockDeleteItemParams{ctx, userID, skuID}
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the StorageMock.DeleteItem
func (mmDeleteItem *mStorageMockMockDeleteItem) Inspect(f func(ctx context.Context, userID int64, skuID int64)) *mStorageMockMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for StorageMockMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by StorageMock.DeleteItem
func (mmDeleteItem *mStorageMockMockDeleteItem) Return(err error) *StorageMockMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMockMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &StorageMockMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &StorageMockMockDeleteItemResults{err}
	return mmDeleteItem.mock
}

// Set uses given function f to mock the StorageMock.DeleteItem method
func (mmDeleteItem *mStorageMockMockDeleteItem) Set(f func(ctx context.Context, userID int64, skuID int64) (err error)) *StorageMockMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the StorageMock.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the StorageMock.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	return mmDeleteItem.mock
}

// When sets expectation for the StorageMock.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mStorageMockMockDeleteItem) When(ctx context.Context, userID int64, skuID int64) *StorageMockMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMockMock.DeleteItem mock is already set by Set")
	}

	expectation := &StorageMockMockDeleteItemExpectation{
		mock:   mmDeleteItem.mock,
		params: &StorageMockMockDeleteItemParams{ctx, userID, skuID},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up StorageMock.DeleteItem return parameters for the expectation previously defined by the When method
func (e *StorageMockMockDeleteItemExpectation) Then(err error) *StorageMockMock {
	e.results = &StorageMockMockDeleteItemResults{err}
	return e.mock
}

// DeleteItem implements cartstorage.StorageMock
func (mmDeleteItem *StorageMockMock) DeleteItem(ctx context.Context, userID int64, skuID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userID, skuID)
	}

	mm_params := &StorageMockMockDeleteItemParams{ctx, userID, skuID}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_got := StorageMockMockDeleteItemParams{ctx, userID, skuID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("StorageMockMock.DeleteItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the StorageMockMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userID, skuID)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to StorageMockMock.DeleteItem. %v %v %v", ctx, userID, skuID)
	return
}

// DeleteItemAfterCounter returns a count of finished StorageMockMock.DeleteItem invocations
func (mmDeleteItem *StorageMockMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of StorageMockMock.DeleteItem invocations
func (mmDeleteItem *StorageMockMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to StorageMockMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mStorageMockMockDeleteItem) Calls() []*StorageMockMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*StorageMockMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *StorageMockMock) MinimockDeleteItemDone() bool {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *StorageMockMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMockMock.DeleteItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMockMock.DeleteItem")
		} else {
			m.t.Errorf("Expected call to StorageMockMock.DeleteItem with params: %#v", *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		m.t.Error("Expected call to StorageMockMock.DeleteItem")
	}
}

type mStorageMockMockDeleteItemsByUserID struct {
	mock               *StorageMockMock
	defaultExpectation *StorageMockMockDeleteItemsByUserIDExpectation
	expectations       []*StorageMockMockDeleteItemsByUserIDExpectation

	callArgs []*StorageMockMockDeleteItemsByUserIDParams
	mutex    sync.RWMutex
}

// StorageMockMockDeleteItemsByUserIDExpectation specifies expectation struct of the StorageMock.DeleteItemsByUserID
type StorageMockMockDeleteItemsByUserIDExpectation struct {
	mock    *StorageMockMock
	params  *StorageMockMockDeleteItemsByUserIDParams
	results *StorageMockMockDeleteItemsByUserIDResults
	Counter uint64
}

// StorageMockMockDeleteItemsByUserIDParams contains parameters of the StorageMock.DeleteItemsByUserID
type StorageMockMockDeleteItemsByUserIDParams struct {
	ctx    context.Context
	userID int64
}

// StorageMockMockDeleteItemsByUserIDResults contains results of the StorageMock.DeleteItemsByUserID
type StorageMockMockDeleteItemsByUserIDResults struct {
	err error
}

// Expect sets up expected params for StorageMock.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mStorageMockMockDeleteItemsByUserID) Expect(ctx context.Context, userID int64) *mStorageMockMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("StorageMockMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &StorageMockMockDeleteItemsByUserIDExpectation{}
	}

	mmDeleteItemsByUserID.defaultExpectation.params = &StorageMockMockDeleteItemsByUserIDParams{ctx, userID}
	for _, e := range mmDeleteItemsByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteItemsByUserID.defaultExpectation.params) {
			mmDeleteItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemsByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the StorageMock.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mStorageMockMockDeleteItemsByUserID) Inspect(f func(ctx context.Context, userID int64)) *mStorageMockMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Inspect function is already set for StorageMockMock.DeleteItemsByUserID")
	}

	mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID = f

	return mmDeleteItemsByUserID
}

// Return sets up results that will be returned by StorageMock.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mStorageMockMockDeleteItemsByUserID) Return(err error) *StorageMockMock {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("StorageMockMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &StorageMockMockDeleteItemsByUserIDExpectation{mock: mmDeleteItemsByUserID.mock}
	}
	mmDeleteItemsByUserID.defaultExpectation.results = &StorageMockMockDeleteItemsByUserIDResults{err}
	return mmDeleteItemsByUserID.mock
}

// Set uses given function f to mock the StorageMock.DeleteItemsByUserID method
func (mmDeleteItemsByUserID *mStorageMockMockDeleteItemsByUserID) Set(f func(ctx context.Context, userID int64) (err error)) *StorageMockMock {
	if mmDeleteItemsByUserID.defaultExpectation != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Default expectation is already set for the StorageMock.DeleteItemsByUserID method")
	}

	if len(mmDeleteItemsByUserID.expectations) > 0 {
		mmDeleteItemsByUserID.mock.t.Fatalf("Some expectations are already set for the StorageMock.DeleteItemsByUserID method")
	}

	mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID = f
	return mmDeleteItemsByUserID.mock
}

// When sets expectation for the StorageMock.DeleteItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmDeleteItemsByUserID *mStorageMockMockDeleteItemsByUserID) When(ctx context.Context, userID int64) *StorageMockMockDeleteItemsByUserIDExpectation {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("StorageMockMock.DeleteItemsByUserID mock is already set by Set")
	}

	expectation := &StorageMockMockDeleteItemsByUserIDExpectation{
		mock:   mmDeleteItemsByUserID.mock,
		params: &StorageMockMockDeleteItemsByUserIDParams{ctx, userID},
	}
	mmDeleteItemsByUserID.expectations = append(mmDeleteItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up StorageMock.DeleteItemsByUserID return parameters for the expectation previously defined by the When method
func (e *StorageMockMockDeleteItemsByUserIDExpectation) Then(err error) *StorageMockMock {
	e.results = &StorageMockMockDeleteItemsByUserIDResults{err}
	return e.mock
}

// DeleteItemsByUserID implements cartstorage.StorageMock
func (mmDeleteItemsByUserID *StorageMockMock) DeleteItemsByUserID(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter, 1)

	if mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID(ctx, userID)
	}

	mm_params := &StorageMockMockDeleteItemsByUserIDParams{ctx, userID}

	// Record call args
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Lock()
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs = append(mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs, mm_params)
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteItemsByUserID.DeleteItemsByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.params
		mm_got := StorageMockMockDeleteItemsByUserIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemsByUserID.t.Errorf("StorageMockMock.DeleteItemsByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemsByUserID.t.Fatal("No results are set for the StorageMockMock.DeleteItemsByUserID")
		}
		return (*mm_results).err
	}
	if mmDeleteItemsByUserID.funcDeleteItemsByUserID != nil {
		return mmDeleteItemsByUserID.funcDeleteItemsByUserID(ctx, userID)
	}
	mmDeleteItemsByUserID.t.Fatalf("Unexpected call to StorageMockMock.DeleteItemsByUserID. %v %v", ctx, userID)
	return
}

// DeleteItemsByUserIDAfterCounter returns a count of finished StorageMockMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *StorageMockMock) DeleteItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter)
}

// DeleteItemsByUserIDBeforeCounter returns a count of StorageMockMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *StorageMockMock) DeleteItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMockMock.DeleteItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemsByUserID *mStorageMockMockDeleteItemsByUserID) Calls() []*StorageMockMockDeleteItemsByUserIDParams {
	mmDeleteItemsByUserID.mutex.RLock()

	argCopy := make([]*StorageMockMockDeleteItemsByUserIDParams, len(mmDeleteItemsByUserID.callArgs))
	copy(argCopy, mmDeleteItemsByUserID.callArgs)

	mmDeleteItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsByUserIDDone returns true if the count of the DeleteItemsByUserID invocations corresponds
// the number of defined expectations
func (m *StorageMockMock) MinimockDeleteItemsByUserIDDone() bool {
	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUserID != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteItemsByUserIDInspect logs each unmet expectation
func (m *StorageMockMock) MinimockDeleteItemsByUserIDInspect() {
	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMockMock.DeleteItemsByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter) < 1 {
		if m.DeleteItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMockMock.DeleteItemsByUserID")
		} else {
			m.t.Errorf("Expected call to StorageMockMock.DeleteItemsByUserID with params: %#v", *m.DeleteItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUserID != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter) < 1 {
		m.t.Error("Expected call to StorageMockMock.DeleteItemsByUserID")
	}
}

type mStorageMockMockGetItemsByUserID struct {
	mock               *StorageMockMock
	defaultExpectation *StorageMockMockGetItemsByUserIDExpectation
	expectations       []*StorageMockMockGetItemsByUserIDExpectation

	callArgs []*StorageMockMockGetItemsByUserIDParams
	mutex    sync.RWMutex
}

// StorageMockMockGetItemsByUserIDExpectation specifies expectation struct of the StorageMock.GetItemsByUserID
type StorageMockMockGetItemsByUserIDExpectation struct {
	mock    *StorageMockMock
	params  *StorageMockMockGetItemsByUserIDParams
	results *StorageMockMockGetItemsByUserIDResults
	Counter uint64
}

// StorageMockMockGetItemsByUserIDParams contains parameters of the StorageMock.GetItemsByUserID
type StorageMockMockGetItemsByUserIDParams struct {
	ctx    context.Context
	userID int64
}

// StorageMockMockGetItemsByUserIDResults contains results of the StorageMock.GetItemsByUserID
type StorageMockMockGetItemsByUserIDResults struct {
	cp1 *mm_cartstorage.Cart
	err error
}

// Expect sets up expected params for StorageMock.GetItemsByUserID
func (mmGetItemsByUserID *mStorageMockMockGetItemsByUserID) Expect(ctx context.Context, userID int64) *mStorageMockMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("StorageMockMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &StorageMockMockGetItemsByUserIDExpectation{}
	}

	mmGetItemsByUserID.defaultExpectation.params = &StorageMockMockGetItemsByUserIDParams{ctx, userID}
	for _, e := range mmGetItemsByUserID.expectations {
		if minimock.Equal(e.params, mmGetItemsByUserID.defaultExpectation.params) {
			mmGetItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByUserID.defaultExpectation.params)
		}
	}

	return mmGetItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the StorageMock.GetItemsByUserID
func (mmGetItemsByUserID *mStorageMockMockGetItemsByUserID) Inspect(f func(ctx context.Context, userID int64)) *mStorageMockMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Inspect function is already set for StorageMockMock.GetItemsByUserID")
	}

	mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID = f

	return mmGetItemsByUserID
}

// Return sets up results that will be returned by StorageMock.GetItemsByUserID
func (mmGetItemsByUserID *mStorageMockMockGetItemsByUserID) Return(cp1 *mm_cartstorage.Cart, err error) *StorageMockMock {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("StorageMockMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &StorageMockMockGetItemsByUserIDExpectation{mock: mmGetItemsByUserID.mock}
	}
	mmGetItemsByUserID.defaultExpectation.results = &StorageMockMockGetItemsByUserIDResults{cp1, err}
	return mmGetItemsByUserID.mock
}

// Set uses given function f to mock the StorageMock.GetItemsByUserID method
func (mmGetItemsByUserID *mStorageMockMockGetItemsByUserID) Set(f func(ctx context.Context, userID int64) (cp1 *mm_cartstorage.Cart, err error)) *StorageMockMock {
	if mmGetItemsByUserID.defaultExpectation != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Default expectation is already set for the StorageMock.GetItemsByUserID method")
	}

	if len(mmGetItemsByUserID.expectations) > 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Some expectations are already set for the StorageMock.GetItemsByUserID method")
	}

	mmGetItemsByUserID.mock.funcGetItemsByUserID = f
	return mmGetItemsByUserID.mock
}

// When sets expectation for the StorageMock.GetItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmGetItemsByUserID *mStorageMockMockGetItemsByUserID) When(ctx context.Context, userID int64) *StorageMockMockGetItemsByUserIDExpectation {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("StorageMockMock.GetItemsByUserID mock is already set by Set")
	}

	expectation := &StorageMockMockGetItemsByUserIDExpectation{
		mock:   mmGetItemsByUserID.mock,
		params: &StorageMockMockGetItemsByUserIDParams{ctx, userID},
	}
	mmGetItemsByUserID.expectations = append(mmGetItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up StorageMock.GetItemsByUserID return parameters for the expectation previously defined by the When method
func (e *StorageMockMockGetItemsByUserIDExpectation) Then(cp1 *mm_cartstorage.Cart, err error) *StorageMockMock {
	e.results = &StorageMockMockGetItemsByUserIDResults{cp1, err}
	return e.mock
}

// GetItemsByUserID implements cartstorage.StorageMock
func (mmGetItemsByUserID *StorageMockMock) GetItemsByUserID(ctx context.Context, userID int64) (cp1 *mm_cartstorage.Cart, err error) {
	mm_atomic.AddUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter, 1)

	if mmGetItemsByUserID.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.inspectFuncGetItemsByUserID(ctx, userID)
	}

	mm_params := &StorageMockMockGetItemsByUserIDParams{ctx, userID}

	// Record call args
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Lock()
	mmGetItemsByUserID.GetItemsByUserIDMock.callArgs = append(mmGetItemsByUserID.GetItemsByUserIDMock.callArgs, mm_params)
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmGetItemsByUserID.GetItemsByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.params
		mm_got := StorageMockMockGetItemsByUserIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByUserID.t.Errorf("StorageMockMock.GetItemsByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByUserID.t.Fatal("No results are set for the StorageMockMock.GetItemsByUserID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetItemsByUserID.funcGetItemsByUserID != nil {
		return mmGetItemsByUserID.funcGetItemsByUserID(ctx, userID)
	}
	mmGetItemsByUserID.t.Fatalf("Unexpected call to StorageMockMock.GetItemsByUserID. %v %v", ctx, userID)
	return
}

// GetItemsByUserIDAfterCounter returns a count of finished StorageMockMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *StorageMockMock) GetItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter)
}

// GetItemsByUserIDBeforeCounter returns a count of StorageMockMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *StorageMockMock) GetItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMockMock.GetItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByUserID *mStorageMockMockGetItemsByUserID) Calls() []*StorageMockMockGetItemsByUserIDParams {
	mmGetItemsByUserID.mutex.RLock()

	argCopy := make([]*StorageMockMockGetItemsByUserIDParams, len(mmGetItemsByUserID.callArgs))
	copy(argCopy, mmGetItemsByUserID.callArgs)

	mmGetItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByUserIDDone returns true if the count of the GetItemsByUserID invocations corresponds
// the number of defined expectations
func (m *StorageMockMock) MinimockGetItemsByUserIDDone() bool {
	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserID != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetItemsByUserIDInspect logs each unmet expectation
func (m *StorageMockMock) MinimockGetItemsByUserIDInspect() {
	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMockMock.GetItemsByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter) < 1 {
		if m.GetItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMockMock.GetItemsByUserID")
		} else {
			m.t.Errorf("Expected call to StorageMockMock.GetItemsByUserID with params: %#v", *m.GetItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserID != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter) < 1 {
		m.t.Error("Expected call to StorageMockMock.GetItemsByUserID")
	}
}

type mStorageMockMockReset struct {
	mock               *StorageMockMock
	defaultExpectation *StorageMockMockResetExpectation
	expectations       []*StorageMockMockResetExpectation
}

// StorageMockMockResetExpectation specifies expectation struct of the StorageMock.Reset
type StorageMockMockResetExpectation struct {
	mock *StorageMockMock

	Counter uint64
}

// Expect sets up expected params for StorageMock.Reset
func (mmReset *mStorageMockMockReset) Expect() *mStorageMockMockReset {
	if mmReset.mock.funcReset != nil {
		mmReset.mock.t.Fatalf("StorageMockMock.Reset mock is already set by Set")
	}

	if mmReset.defaultExpectation == nil {
		mmReset.defaultExpectation = &StorageMockMockResetExpectation{}
	}

	return mmReset
}

// Inspect accepts an inspector function that has same arguments as the StorageMock.Reset
func (mmReset *mStorageMockMockReset) Inspect(f func()) *mStorageMockMockReset {
	if mmReset.mock.inspectFuncReset != nil {
		mmReset.mock.t.Fatalf("Inspect function is already set for StorageMockMock.Reset")
	}

	mmReset.mock.inspectFuncReset = f

	return mmReset
}

// Return sets up results that will be returned by StorageMock.Reset
func (mmReset *mStorageMockMockReset) Return() *StorageMockMock {
	if mmReset.mock.funcReset != nil {
		mmReset.mock.t.Fatalf("StorageMockMock.Reset mock is already set by Set")
	}

	if mmReset.defaultExpectation == nil {
		mmReset.defaultExpectation = &StorageMockMockResetExpectation{mock: mmReset.mock}
	}

	return mmReset.mock
}

// Set uses given function f to mock the StorageMock.Reset method
func (mmReset *mStorageMockMockReset) Set(f func()) *StorageMockMock {
	if mmReset.defaultExpectation != nil {
		mmReset.mock.t.Fatalf("Default expectation is already set for the StorageMock.Reset method")
	}

	if len(mmReset.expectations) > 0 {
		mmReset.mock.t.Fatalf("Some expectations are already set for the StorageMock.Reset method")
	}

	mmReset.mock.funcReset = f
	return mmReset.mock
}

// Reset implements cartstorage.StorageMock
func (mmReset *StorageMockMock) Reset() {
	mm_atomic.AddUint64(&mmReset.beforeResetCounter, 1)
	defer mm_atomic.AddUint64(&mmReset.afterResetCounter, 1)

	if mmReset.inspectFuncReset != nil {
		mmReset.inspectFuncReset()
	}

	if mmReset.ResetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReset.ResetMock.defaultExpectation.Counter, 1)

		return

	}
	if mmReset.funcReset != nil {
		mmReset.funcReset()
		return
	}
	mmReset.t.Fatalf("Unexpected call to StorageMockMock.Reset.")

}

// ResetAfterCounter returns a count of finished StorageMockMock.Reset invocations
func (mmReset *StorageMockMock) ResetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReset.afterResetCounter)
}

// ResetBeforeCounter returns a count of StorageMockMock.Reset invocations
func (mmReset *StorageMockMock) ResetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReset.beforeResetCounter)
}

// MinimockResetDone returns true if the count of the Reset invocations corresponds
// the number of defined expectations
func (m *StorageMockMock) MinimockResetDone() bool {
	for _, e := range m.ResetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReset != nil && mm_atomic.LoadUint64(&m.afterResetCounter) < 1 {
		return false
	}
	return true
}

// MinimockResetInspect logs each unmet expectation
func (m *StorageMockMock) MinimockResetInspect() {
	for _, e := range m.ResetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMockMock.Reset")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResetCounter) < 1 {
		m.t.Error("Expected call to StorageMockMock.Reset")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReset != nil && mm_atomic.LoadUint64(&m.afterResetCounter) < 1 {
		m.t.Error("Expected call to StorageMockMock.Reset")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMockMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddItemInspect()

		m.MinimockDeleteItemInspect()

		m.MinimockDeleteItemsByUserIDInspect()

		m.MinimockGetItemsByUserIDInspect()

		m.MinimockResetInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMockMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMockMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockDeleteItemsByUserIDDone() &&
		m.MinimockGetItemsByUserIDDone() &&
		m.MinimockResetDone()
}
